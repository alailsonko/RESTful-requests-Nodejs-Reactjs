/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.12.4
 * source: base/v1/base.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from './../../google/api/expr/v1alpha1/checked';
import * as dependency_2 from './../../google/protobuf/any';
import * as dependency_3 from './../../google/protobuf/struct';
import * as dependency_4 from './../../google/protobuf/timestamp';
import * as dependency_5 from './../../validate/validate';
import * as pb_1 from 'google-protobuf';
export namespace base.v1 {
  export enum CheckResult {
    CHECK_RESULT_UNSPECIFIED = 0,
    CHECK_RESULT_ALLOWED = 1,
    CHECK_RESULT_DENIED = 2,
  }
  export enum AttributeType {
    ATTRIBUTE_TYPE_UNSPECIFIED = 0,
    ATTRIBUTE_TYPE_BOOLEAN = 1,
    ATTRIBUTE_TYPE_BOOLEAN_ARRAY = 2,
    ATTRIBUTE_TYPE_STRING = 3,
    ATTRIBUTE_TYPE_STRING_ARRAY = 4,
    ATTRIBUTE_TYPE_INTEGER = 5,
    ATTRIBUTE_TYPE_INTEGER_ARRAY = 6,
    ATTRIBUTE_TYPE_DOUBLE = 7,
    ATTRIBUTE_TYPE_DOUBLE_ARRAY = 8,
  }
  export class Context extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            tuples?: Tuple[];
            attributes?: Attribute[];
            data?: dependency_3.google.protobuf.Struct;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1, 2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('tuples' in data && data.tuples != undefined) {
          this.tuples = data.tuples;
        }
        if ('attributes' in data && data.attributes != undefined) {
          this.attributes = data.attributes;
        }
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get tuples() {
      return pb_1.Message.getRepeatedWrapperField(this, Tuple, 1) as Tuple[];
    }
    set tuples(value: Tuple[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    get attributes() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Attribute,
        2,
      ) as Attribute[];
    }
    set attributes(value: Attribute[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    get data() {
      return pb_1.Message.getWrapperField(
        this,
        dependency_3.google.protobuf.Struct,
        3,
      ) as dependency_3.google.protobuf.Struct;
    }
    set data(value: dependency_3.google.protobuf.Struct) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_data() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      tuples?: ReturnType<typeof Tuple.prototype.toObject>[];
      attributes?: ReturnType<typeof Attribute.prototype.toObject>[];
      data?: ReturnType<
        typeof dependency_3.google.protobuf.Struct.prototype.toObject
      >;
    }): Context {
      const message = new Context({});
      if (data.tuples != null) {
        message.tuples = data.tuples.map((item) => Tuple.fromObject(item));
      }
      if (data.attributes != null) {
        message.attributes = data.attributes.map((item) =>
          Attribute.fromObject(item),
        );
      }
      if (data.data != null) {
        message.data = dependency_3.google.protobuf.Struct.fromObject(
          data.data,
        );
      }
      return message;
    }
    toObject() {
      const data: {
        tuples?: ReturnType<typeof Tuple.prototype.toObject>[];
        attributes?: ReturnType<typeof Attribute.prototype.toObject>[];
        data?: ReturnType<
          typeof dependency_3.google.protobuf.Struct.prototype.toObject
        >;
      } = {};
      if (this.tuples != null) {
        data.tuples = this.tuples.map((item: Tuple) => item.toObject());
      }
      if (this.attributes != null) {
        data.attributes = this.attributes.map((item: Attribute) =>
          item.toObject(),
        );
      }
      if (this.data != null) {
        data.data = this.data.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.tuples.length)
        writer.writeRepeatedMessage(1, this.tuples, (item: Tuple) =>
          item.serialize(writer),
        );
      if (this.attributes.length)
        writer.writeRepeatedMessage(2, this.attributes, (item: Attribute) =>
          item.serialize(writer),
        );
      if (this.has_data)
        writer.writeMessage(3, this.data, () => this.data.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Context {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Context();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.tuples, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                Tuple.deserialize(reader),
                Tuple,
              ),
            );
            break;
          case 2:
            reader.readMessage(message.attributes, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                Attribute.deserialize(reader),
                Attribute,
              ),
            );
            break;
          case 3:
            reader.readMessage(
              message.data,
              () =>
                (message.data =
                  dependency_3.google.protobuf.Struct.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Context {
      return Context.deserialize(bytes);
    }
  }
  export class Child extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                leaf?: Leaf;
                rewrite?: never;
              }
            | {
                leaf?: never;
                rewrite?: Rewrite;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('leaf' in data && data.leaf != undefined) {
          this.leaf = data.leaf;
        }
        if ('rewrite' in data && data.rewrite != undefined) {
          this.rewrite = data.rewrite;
        }
      }
    }
    get leaf() {
      return pb_1.Message.getWrapperField(this, Leaf, 1) as Leaf;
    }
    set leaf(value: Leaf) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_leaf() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get rewrite() {
      return pb_1.Message.getWrapperField(this, Rewrite, 2) as Rewrite;
    }
    set rewrite(value: Rewrite) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_rewrite() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get type() {
      const cases: {
        [index: number]: 'none' | 'leaf' | 'rewrite';
      } = {
        0: 'none',
        1: 'leaf',
        2: 'rewrite',
      };
      return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    static fromObject(data: {
      leaf?: ReturnType<typeof Leaf.prototype.toObject>;
      rewrite?: ReturnType<typeof Rewrite.prototype.toObject>;
    }): Child {
      const message = new Child({});
      if (data.leaf != null) {
        message.leaf = Leaf.fromObject(data.leaf);
      }
      if (data.rewrite != null) {
        message.rewrite = Rewrite.fromObject(data.rewrite);
      }
      return message;
    }
    toObject() {
      const data: {
        leaf?: ReturnType<typeof Leaf.prototype.toObject>;
        rewrite?: ReturnType<typeof Rewrite.prototype.toObject>;
      } = {};
      if (this.leaf != null) {
        data.leaf = this.leaf.toObject();
      }
      if (this.rewrite != null) {
        data.rewrite = this.rewrite.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_leaf)
        writer.writeMessage(1, this.leaf, () => this.leaf.serialize(writer));
      if (this.has_rewrite)
        writer.writeMessage(2, this.rewrite, () =>
          this.rewrite.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Child {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Child();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.leaf,
              () => (message.leaf = Leaf.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.rewrite,
              () => (message.rewrite = Rewrite.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Child {
      return Child.deserialize(bytes);
    }
  }
  export class Leaf extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3, 4]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                computed_user_set?: ComputedUserSet;
                tuple_to_user_set?: never;
                computed_attribute?: never;
                call?: never;
              }
            | {
                computed_user_set?: never;
                tuple_to_user_set?: TupleToUserSet;
                computed_attribute?: never;
                call?: never;
              }
            | {
                computed_user_set?: never;
                tuple_to_user_set?: never;
                computed_attribute?: ComputedAttribute;
                call?: never;
              }
            | {
                computed_user_set?: never;
                tuple_to_user_set?: never;
                computed_attribute?: never;
                call?: Call;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if (
          'computed_user_set' in data &&
          data.computed_user_set != undefined
        ) {
          this.computed_user_set = data.computed_user_set;
        }
        if (
          'tuple_to_user_set' in data &&
          data.tuple_to_user_set != undefined
        ) {
          this.tuple_to_user_set = data.tuple_to_user_set;
        }
        if (
          'computed_attribute' in data &&
          data.computed_attribute != undefined
        ) {
          this.computed_attribute = data.computed_attribute;
        }
        if ('call' in data && data.call != undefined) {
          this.call = data.call;
        }
      }
    }
    get computed_user_set() {
      return pb_1.Message.getWrapperField(
        this,
        ComputedUserSet,
        1,
      ) as ComputedUserSet;
    }
    set computed_user_set(value: ComputedUserSet) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_computed_user_set() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get tuple_to_user_set() {
      return pb_1.Message.getWrapperField(
        this,
        TupleToUserSet,
        2,
      ) as TupleToUserSet;
    }
    set tuple_to_user_set(value: TupleToUserSet) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_tuple_to_user_set() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get computed_attribute() {
      return pb_1.Message.getWrapperField(
        this,
        ComputedAttribute,
        3,
      ) as ComputedAttribute;
    }
    set computed_attribute(value: ComputedAttribute) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_computed_attribute() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get call() {
      return pb_1.Message.getWrapperField(this, Call, 4) as Call;
    }
    set call(value: Call) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_call() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get type() {
      const cases: {
        [index: number]:
          | 'none'
          | 'computed_user_set'
          | 'tuple_to_user_set'
          | 'computed_attribute'
          | 'call';
      } = {
        0: 'none',
        1: 'computed_user_set',
        2: 'tuple_to_user_set',
        3: 'computed_attribute',
        4: 'call',
      };
      return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
    }
    static fromObject(data: {
      computed_user_set?: ReturnType<typeof ComputedUserSet.prototype.toObject>;
      tuple_to_user_set?: ReturnType<typeof TupleToUserSet.prototype.toObject>;
      computed_attribute?: ReturnType<
        typeof ComputedAttribute.prototype.toObject
      >;
      call?: ReturnType<typeof Call.prototype.toObject>;
    }): Leaf {
      const message = new Leaf({});
      if (data.computed_user_set != null) {
        message.computed_user_set = ComputedUserSet.fromObject(
          data.computed_user_set,
        );
      }
      if (data.tuple_to_user_set != null) {
        message.tuple_to_user_set = TupleToUserSet.fromObject(
          data.tuple_to_user_set,
        );
      }
      if (data.computed_attribute != null) {
        message.computed_attribute = ComputedAttribute.fromObject(
          data.computed_attribute,
        );
      }
      if (data.call != null) {
        message.call = Call.fromObject(data.call);
      }
      return message;
    }
    toObject() {
      const data: {
        computed_user_set?: ReturnType<
          typeof ComputedUserSet.prototype.toObject
        >;
        tuple_to_user_set?: ReturnType<
          typeof TupleToUserSet.prototype.toObject
        >;
        computed_attribute?: ReturnType<
          typeof ComputedAttribute.prototype.toObject
        >;
        call?: ReturnType<typeof Call.prototype.toObject>;
      } = {};
      if (this.computed_user_set != null) {
        data.computed_user_set = this.computed_user_set.toObject();
      }
      if (this.tuple_to_user_set != null) {
        data.tuple_to_user_set = this.tuple_to_user_set.toObject();
      }
      if (this.computed_attribute != null) {
        data.computed_attribute = this.computed_attribute.toObject();
      }
      if (this.call != null) {
        data.call = this.call.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_computed_user_set)
        writer.writeMessage(1, this.computed_user_set, () =>
          this.computed_user_set.serialize(writer),
        );
      if (this.has_tuple_to_user_set)
        writer.writeMessage(2, this.tuple_to_user_set, () =>
          this.tuple_to_user_set.serialize(writer),
        );
      if (this.has_computed_attribute)
        writer.writeMessage(3, this.computed_attribute, () =>
          this.computed_attribute.serialize(writer),
        );
      if (this.has_call)
        writer.writeMessage(4, this.call, () => this.call.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Leaf {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Leaf();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.computed_user_set,
              () =>
                (message.computed_user_set =
                  ComputedUserSet.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.tuple_to_user_set,
              () =>
                (message.tuple_to_user_set =
                  TupleToUserSet.deserialize(reader)),
            );
            break;
          case 3:
            reader.readMessage(
              message.computed_attribute,
              () =>
                (message.computed_attribute =
                  ComputedAttribute.deserialize(reader)),
            );
            break;
          case 4:
            reader.readMessage(
              message.call,
              () => (message.call = Call.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Leaf {
      return Leaf.deserialize(bytes);
    }
  }
  export class Rewrite extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            rewrite_operation?: Rewrite.Operation;
            children?: Child[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if (
          'rewrite_operation' in data &&
          data.rewrite_operation != undefined
        ) {
          this.rewrite_operation = data.rewrite_operation;
        }
        if ('children' in data && data.children != undefined) {
          this.children = data.children;
        }
      }
    }
    get rewrite_operation() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        Rewrite.Operation.OPERATION_UNSPECIFIED,
      ) as Rewrite.Operation;
    }
    set rewrite_operation(value: Rewrite.Operation) {
      pb_1.Message.setField(this, 1, value);
    }
    get children() {
      return pb_1.Message.getRepeatedWrapperField(this, Child, 2) as Child[];
    }
    set children(value: Child[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      rewrite_operation?: Rewrite.Operation;
      children?: ReturnType<typeof Child.prototype.toObject>[];
    }): Rewrite {
      const message = new Rewrite({});
      if (data.rewrite_operation != null) {
        message.rewrite_operation = data.rewrite_operation;
      }
      if (data.children != null) {
        message.children = data.children.map((item) => Child.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        rewrite_operation?: Rewrite.Operation;
        children?: ReturnType<typeof Child.prototype.toObject>[];
      } = {};
      if (this.rewrite_operation != null) {
        data.rewrite_operation = this.rewrite_operation;
      }
      if (this.children != null) {
        data.children = this.children.map((item: Child) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.rewrite_operation != Rewrite.Operation.OPERATION_UNSPECIFIED)
        writer.writeEnum(1, this.rewrite_operation);
      if (this.children.length)
        writer.writeRepeatedMessage(2, this.children, (item: Child) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Rewrite {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Rewrite();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.rewrite_operation = reader.readEnum();
            break;
          case 2:
            reader.readMessage(message.children, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                Child.deserialize(reader),
                Child,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Rewrite {
      return Rewrite.deserialize(bytes);
    }
  }
  export namespace Rewrite {
    export enum Operation {
      OPERATION_UNSPECIFIED = 0,
      OPERATION_UNION = 1,
      OPERATION_INTERSECTION = 2,
      OPERATION_EXCLUSION = 3,
    }
  }
  export class SchemaDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity_definitions?: Map<string, EntityDefinition>;
            rule_definitions?: Map<string, RuleDefinition>;
            references?: Map<string, SchemaDefinition.Reference>;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if (
          'entity_definitions' in data &&
          data.entity_definitions != undefined
        ) {
          this.entity_definitions = data.entity_definitions;
        }
        if ('rule_definitions' in data && data.rule_definitions != undefined) {
          this.rule_definitions = data.rule_definitions;
        }
        if ('references' in data && data.references != undefined) {
          this.references = data.references;
        }
      }
      if (!this.entity_definitions) this.entity_definitions = new Map();
      if (!this.rule_definitions) this.rule_definitions = new Map();
      if (!this.references) this.references = new Map();
    }
    get entity_definitions() {
      return pb_1.Message.getField(this, 1) as any as Map<
        string,
        EntityDefinition
      >;
    }
    set entity_definitions(value: Map<string, EntityDefinition>) {
      pb_1.Message.setField(this, 1, value as any);
    }
    get rule_definitions() {
      return pb_1.Message.getField(this, 2) as any as Map<
        string,
        RuleDefinition
      >;
    }
    set rule_definitions(value: Map<string, RuleDefinition>) {
      pb_1.Message.setField(this, 2, value as any);
    }
    get references() {
      return pb_1.Message.getField(this, 3) as any as Map<
        string,
        SchemaDefinition.Reference
      >;
    }
    set references(value: Map<string, SchemaDefinition.Reference>) {
      pb_1.Message.setField(this, 3, value as any);
    }
    static fromObject(data: {
      entity_definitions?: {
        [key: string]: ReturnType<typeof EntityDefinition.prototype.toObject>;
      };
      rule_definitions?: {
        [key: string]: ReturnType<typeof RuleDefinition.prototype.toObject>;
      };
      references?: {
        [key: string]: SchemaDefinition.Reference;
      };
    }): SchemaDefinition {
      const message = new SchemaDefinition({});
      if (typeof data.entity_definitions == 'object') {
        message.entity_definitions = new Map(
          Object.entries(data.entity_definitions).map(([key, value]) => [
            key,
            EntityDefinition.fromObject(value),
          ]),
        );
      }
      if (typeof data.rule_definitions == 'object') {
        message.rule_definitions = new Map(
          Object.entries(data.rule_definitions).map(([key, value]) => [
            key,
            RuleDefinition.fromObject(value),
          ]),
        );
      }
      if (typeof data.references == 'object') {
        message.references = new Map(Object.entries(data.references));
      }
      return message;
    }
    toObject() {
      const data: {
        entity_definitions?: {
          [key: string]: ReturnType<typeof EntityDefinition.prototype.toObject>;
        };
        rule_definitions?: {
          [key: string]: ReturnType<typeof RuleDefinition.prototype.toObject>;
        };
        references?: {
          [key: string]: SchemaDefinition.Reference;
        };
      } = {};
      if (this.entity_definitions != null) {
        data.entity_definitions = Object.fromEntries(
          Array.from(this.entity_definitions).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      if (this.rule_definitions != null) {
        data.rule_definitions = Object.fromEntries(
          Array.from(this.rule_definitions).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      if (this.references != null) {
        data.references = Object.fromEntries(this.references);
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      for (const [key, value] of this.entity_definitions) {
        writer.writeMessage(1, this.entity_definitions, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      for (const [key, value] of this.rule_definitions) {
        writer.writeMessage(2, this.rule_definitions, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      for (const [key, value] of this.references) {
        writer.writeMessage(3, this.references, () => {
          writer.writeString(1, key);
          writer.writeEnum(2, value);
        });
      }
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): SchemaDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new SchemaDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.entity_definitions as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () => (value = EntityDefinition.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          case 2:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.rule_definitions as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () => (value = RuleDefinition.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          case 3:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.references as any,
                reader,
                reader.readString,
                reader.readEnum,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SchemaDefinition {
      return SchemaDefinition.deserialize(bytes);
    }
  }
  export namespace SchemaDefinition {
    export enum Reference {
      REFERENCE_UNSPECIFIED = 0,
      REFERENCE_ENTITY = 1,
      REFERENCE_RULE = 2,
    }
  }
  export class EntityDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            relations?: Map<string, RelationDefinition>;
            permissions?: Map<string, PermissionDefinition>;
            attributes?: Map<string, AttributeDefinition>;
            references?: Map<string, EntityDefinition.Reference>;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('relations' in data && data.relations != undefined) {
          this.relations = data.relations;
        }
        if ('permissions' in data && data.permissions != undefined) {
          this.permissions = data.permissions;
        }
        if ('attributes' in data && data.attributes != undefined) {
          this.attributes = data.attributes;
        }
        if ('references' in data && data.references != undefined) {
          this.references = data.references;
        }
      }
      if (!this.relations) this.relations = new Map();
      if (!this.permissions) this.permissions = new Map();
      if (!this.attributes) this.attributes = new Map();
      if (!this.references) this.references = new Map();
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get relations() {
      return pb_1.Message.getField(this, 2) as any as Map<
        string,
        RelationDefinition
      >;
    }
    set relations(value: Map<string, RelationDefinition>) {
      pb_1.Message.setField(this, 2, value as any);
    }
    get permissions() {
      return pb_1.Message.getField(this, 3) as any as Map<
        string,
        PermissionDefinition
      >;
    }
    set permissions(value: Map<string, PermissionDefinition>) {
      pb_1.Message.setField(this, 3, value as any);
    }
    get attributes() {
      return pb_1.Message.getField(this, 4) as any as Map<
        string,
        AttributeDefinition
      >;
    }
    set attributes(value: Map<string, AttributeDefinition>) {
      pb_1.Message.setField(this, 4, value as any);
    }
    get references() {
      return pb_1.Message.getField(this, 5) as any as Map<
        string,
        EntityDefinition.Reference
      >;
    }
    set references(value: Map<string, EntityDefinition.Reference>) {
      pb_1.Message.setField(this, 5, value as any);
    }
    static fromObject(data: {
      name?: string;
      relations?: {
        [key: string]: ReturnType<typeof RelationDefinition.prototype.toObject>;
      };
      permissions?: {
        [key: string]: ReturnType<
          typeof PermissionDefinition.prototype.toObject
        >;
      };
      attributes?: {
        [key: string]: ReturnType<
          typeof AttributeDefinition.prototype.toObject
        >;
      };
      references?: {
        [key: string]: EntityDefinition.Reference;
      };
    }): EntityDefinition {
      const message = new EntityDefinition({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (typeof data.relations == 'object') {
        message.relations = new Map(
          Object.entries(data.relations).map(([key, value]) => [
            key,
            RelationDefinition.fromObject(value),
          ]),
        );
      }
      if (typeof data.permissions == 'object') {
        message.permissions = new Map(
          Object.entries(data.permissions).map(([key, value]) => [
            key,
            PermissionDefinition.fromObject(value),
          ]),
        );
      }
      if (typeof data.attributes == 'object') {
        message.attributes = new Map(
          Object.entries(data.attributes).map(([key, value]) => [
            key,
            AttributeDefinition.fromObject(value),
          ]),
        );
      }
      if (typeof data.references == 'object') {
        message.references = new Map(Object.entries(data.references));
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        relations?: {
          [key: string]: ReturnType<
            typeof RelationDefinition.prototype.toObject
          >;
        };
        permissions?: {
          [key: string]: ReturnType<
            typeof PermissionDefinition.prototype.toObject
          >;
        };
        attributes?: {
          [key: string]: ReturnType<
            typeof AttributeDefinition.prototype.toObject
          >;
        };
        references?: {
          [key: string]: EntityDefinition.Reference;
        };
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.relations != null) {
        data.relations = Object.fromEntries(
          Array.from(this.relations).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      if (this.permissions != null) {
        data.permissions = Object.fromEntries(
          Array.from(this.permissions).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      if (this.attributes != null) {
        data.attributes = Object.fromEntries(
          Array.from(this.attributes).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      if (this.references != null) {
        data.references = Object.fromEntries(this.references);
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      for (const [key, value] of this.relations) {
        writer.writeMessage(2, this.relations, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      for (const [key, value] of this.permissions) {
        writer.writeMessage(3, this.permissions, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      for (const [key, value] of this.attributes) {
        writer.writeMessage(4, this.attributes, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      for (const [key, value] of this.references) {
        writer.writeMessage(5, this.references, () => {
          writer.writeString(1, key);
          writer.writeEnum(2, value);
        });
      }
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EntityDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new EntityDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.relations as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () => (value = RelationDefinition.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          case 3:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.permissions as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () => (value = PermissionDefinition.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          case 4:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.attributes as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () => (value = AttributeDefinition.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          case 5:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.references as any,
                reader,
                reader.readString,
                reader.readEnum,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EntityDefinition {
      return EntityDefinition.deserialize(bytes);
    }
  }
  export namespace EntityDefinition {
    export enum Reference {
      REFERENCE_UNSPECIFIED = 0,
      REFERENCE_RELATION = 1,
      REFERENCE_PERMISSION = 2,
      REFERENCE_ATTRIBUTE = 3,
    }
  }
  export class RuleDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            arguments?: Map<string, AttributeType>;
            expression?: dependency_1.google.api.expr.v1alpha1.CheckedExpr;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('arguments' in data && data.arguments != undefined) {
          this.arguments = data.arguments;
        }
        if ('expression' in data && data.expression != undefined) {
          this.expression = data.expression;
        }
      }
      if (!this.arguments) this.arguments = new Map();
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get arguments() {
      return pb_1.Message.getField(this, 2) as any as Map<
        string,
        AttributeType
      >;
    }
    set arguments(value: Map<string, AttributeType>) {
      pb_1.Message.setField(this, 2, value as any);
    }
    get expression() {
      return pb_1.Message.getWrapperField(
        this,
        dependency_1.google.api.expr.v1alpha1.CheckedExpr,
        3,
      ) as dependency_1.google.api.expr.v1alpha1.CheckedExpr;
    }
    set expression(value: dependency_1.google.api.expr.v1alpha1.CheckedExpr) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_expression() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      name?: string;
      arguments?: {
        [key: string]: AttributeType;
      };
      expression?: ReturnType<
        typeof dependency_1.google.api.expr.v1alpha1.CheckedExpr.prototype.toObject
      >;
    }): RuleDefinition {
      const message = new RuleDefinition({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (typeof data.arguments == 'object') {
        message.arguments = new Map(Object.entries(data.arguments));
      }
      if (data.expression != null) {
        message.expression =
          dependency_1.google.api.expr.v1alpha1.CheckedExpr.fromObject(
            data.expression,
          );
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        arguments?: {
          [key: string]: AttributeType;
        };
        expression?: ReturnType<
          typeof dependency_1.google.api.expr.v1alpha1.CheckedExpr.prototype.toObject
        >;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.arguments != null) {
        data.arguments = Object.fromEntries(this.arguments);
      }
      if (this.expression != null) {
        data.expression = this.expression.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      for (const [key, value] of this.arguments) {
        writer.writeMessage(2, this.arguments, () => {
          writer.writeString(1, key);
          writer.writeEnum(2, value);
        });
      }
      if (this.has_expression)
        writer.writeMessage(3, this.expression, () =>
          this.expression.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RuleDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new RuleDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.arguments as any,
                reader,
                reader.readString,
                reader.readEnum,
              ),
            );
            break;
          case 3:
            reader.readMessage(
              message.expression,
              () =>
                (message.expression =
                  dependency_1.google.api.expr.v1alpha1.CheckedExpr.deserialize(
                    reader,
                  )),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RuleDefinition {
      return RuleDefinition.deserialize(bytes);
    }
  }
  export class AttributeDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            type?: AttributeType;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(
        this,
        2,
        AttributeType.ATTRIBUTE_TYPE_UNSPECIFIED,
      ) as AttributeType;
    }
    set type(value: AttributeType) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      name?: string;
      type?: AttributeType;
    }): AttributeDefinition {
      const message = new AttributeDefinition({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.type != null) {
        message.type = data.type;
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        type?: AttributeType;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.type != null) {
        data.type = this.type;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (this.type != AttributeType.ATTRIBUTE_TYPE_UNSPECIFIED)
        writer.writeEnum(2, this.type);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): AttributeDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new AttributeDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            message.type = reader.readEnum();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AttributeDefinition {
      return AttributeDefinition.deserialize(bytes);
    }
  }
  export class RelationDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            relation_references?: RelationReference[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if (
          'relation_references' in data &&
          data.relation_references != undefined
        ) {
          this.relation_references = data.relation_references;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get relation_references() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        RelationReference,
        2,
      ) as RelationReference[];
    }
    set relation_references(value: RelationReference[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      name?: string;
      relation_references?: ReturnType<
        typeof RelationReference.prototype.toObject
      >[];
    }): RelationDefinition {
      const message = new RelationDefinition({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.relation_references != null) {
        message.relation_references = data.relation_references.map((item) =>
          RelationReference.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        relation_references?: ReturnType<
          typeof RelationReference.prototype.toObject
        >[];
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.relation_references != null) {
        data.relation_references = this.relation_references.map(
          (item: RelationReference) => item.toObject(),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (this.relation_references.length)
        writer.writeRepeatedMessage(
          2,
          this.relation_references,
          (item: RelationReference) => item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): RelationDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new RelationDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            reader.readMessage(message.relation_references, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                RelationReference.deserialize(reader),
                RelationReference,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RelationDefinition {
      return RelationDefinition.deserialize(bytes);
    }
  }
  export class PermissionDefinition extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            child?: Child;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('child' in data && data.child != undefined) {
          this.child = data.child;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get child() {
      return pb_1.Message.getWrapperField(this, Child, 2) as Child;
    }
    set child(value: Child) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_child() {
      return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
      name?: string;
      child?: ReturnType<typeof Child.prototype.toObject>;
    }): PermissionDefinition {
      const message = new PermissionDefinition({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.child != null) {
        message.child = Child.fromObject(data.child);
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        child?: ReturnType<typeof Child.prototype.toObject>;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.child != null) {
        data.child = this.child.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (this.has_child)
        writer.writeMessage(2, this.child, () => this.child.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): PermissionDefinition {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new PermissionDefinition();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            reader.readMessage(
              message.child,
              () => (message.child = Child.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PermissionDefinition {
      return PermissionDefinition.deserialize(bytes);
    }
  }
  export class RelationReference extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            type?: string;
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set type(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      type?: string;
      relation?: string;
    }): RelationReference {
      const message = new RelationReference({});
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        type?: string;
        relation?: string;
      } = {};
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.type.length) writer.writeString(1, this.type);
      if (this.relation.length) writer.writeString(2, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): RelationReference {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new RelationReference();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.type = reader.readString();
            break;
          case 2:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RelationReference {
      return RelationReference.deserialize(bytes);
    }
  }
  export class Argument extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                computed_attribute?: ComputedAttribute;
                context_attribute?: never;
              }
            | {
                computed_attribute?: never;
                context_attribute?: ContextAttribute;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if (
          'computed_attribute' in data &&
          data.computed_attribute != undefined
        ) {
          this.computed_attribute = data.computed_attribute;
        }
        if (
          'context_attribute' in data &&
          data.context_attribute != undefined
        ) {
          this.context_attribute = data.context_attribute;
        }
      }
    }
    get computed_attribute() {
      return pb_1.Message.getWrapperField(
        this,
        ComputedAttribute,
        1,
      ) as ComputedAttribute;
    }
    set computed_attribute(value: ComputedAttribute) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_computed_attribute() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get context_attribute() {
      return pb_1.Message.getWrapperField(
        this,
        ContextAttribute,
        2,
      ) as ContextAttribute;
    }
    set context_attribute(value: ContextAttribute) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_context_attribute() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get type() {
      const cases: {
        [index: number]: 'none' | 'computed_attribute' | 'context_attribute';
      } = {
        0: 'none',
        1: 'computed_attribute',
        2: 'context_attribute',
      };
      return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    static fromObject(data: {
      computed_attribute?: ReturnType<
        typeof ComputedAttribute.prototype.toObject
      >;
      context_attribute?: ReturnType<
        typeof ContextAttribute.prototype.toObject
      >;
    }): Argument {
      const message = new Argument({});
      if (data.computed_attribute != null) {
        message.computed_attribute = ComputedAttribute.fromObject(
          data.computed_attribute,
        );
      }
      if (data.context_attribute != null) {
        message.context_attribute = ContextAttribute.fromObject(
          data.context_attribute,
        );
      }
      return message;
    }
    toObject() {
      const data: {
        computed_attribute?: ReturnType<
          typeof ComputedAttribute.prototype.toObject
        >;
        context_attribute?: ReturnType<
          typeof ContextAttribute.prototype.toObject
        >;
      } = {};
      if (this.computed_attribute != null) {
        data.computed_attribute = this.computed_attribute.toObject();
      }
      if (this.context_attribute != null) {
        data.context_attribute = this.context_attribute.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_computed_attribute)
        writer.writeMessage(1, this.computed_attribute, () =>
          this.computed_attribute.serialize(writer),
        );
      if (this.has_context_attribute)
        writer.writeMessage(2, this.context_attribute, () =>
          this.context_attribute.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Argument {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Argument();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.computed_attribute,
              () =>
                (message.computed_attribute =
                  ComputedAttribute.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.context_attribute,
              () =>
                (message.context_attribute =
                  ContextAttribute.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Argument {
      return Argument.deserialize(bytes);
    }
  }
  export class Call extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            rule_name?: string;
            arguments?: Argument[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('rule_name' in data && data.rule_name != undefined) {
          this.rule_name = data.rule_name;
        }
        if ('arguments' in data && data.arguments != undefined) {
          this.arguments = data.arguments;
        }
      }
    }
    get rule_name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set rule_name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get arguments() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Argument,
        2,
      ) as Argument[];
    }
    set arguments(value: Argument[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      rule_name?: string;
      arguments?: ReturnType<typeof Argument.prototype.toObject>[];
    }): Call {
      const message = new Call({});
      if (data.rule_name != null) {
        message.rule_name = data.rule_name;
      }
      if (data.arguments != null) {
        message.arguments = data.arguments.map((item) =>
          Argument.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        rule_name?: string;
        arguments?: ReturnType<typeof Argument.prototype.toObject>[];
      } = {};
      if (this.rule_name != null) {
        data.rule_name = this.rule_name;
      }
      if (this.arguments != null) {
        data.arguments = this.arguments.map((item: Argument) =>
          item.toObject(),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.rule_name.length) writer.writeString(1, this.rule_name);
      if (this.arguments.length)
        writer.writeRepeatedMessage(2, this.arguments, (item: Argument) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Call {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Call();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.rule_name = reader.readString();
            break;
          case 2:
            reader.readMessage(message.arguments, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                Argument.deserialize(reader),
                Argument,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Call {
      return Call.deserialize(bytes);
    }
  }
  export class ComputedAttribute extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { name?: string }): ComputedAttribute {
      const message = new ComputedAttribute({});
      if (data.name != null) {
        message.name = data.name;
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): ComputedAttribute {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ComputedAttribute();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ComputedAttribute {
      return ComputedAttribute.deserialize(bytes);
    }
  }
  export class ContextAttribute extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { name?: string }): ContextAttribute {
      const message = new ContextAttribute({});
      if (data.name != null) {
        message.name = data.name;
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): ContextAttribute {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ContextAttribute();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ContextAttribute {
      return ContextAttribute.deserialize(bytes);
    }
  }
  export class ComputedUserSet extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { relation?: string }): ComputedUserSet {
      const message = new ComputedUserSet({});
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        relation?: string;
      } = {};
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.relation.length) writer.writeString(1, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ComputedUserSet {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ComputedUserSet();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ComputedUserSet {
      return ComputedUserSet.deserialize(bytes);
    }
  }
  export class TupleToUserSet extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            tupleSet?: TupleSet;
            computed?: ComputedUserSet;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('tupleSet' in data && data.tupleSet != undefined) {
          this.tupleSet = data.tupleSet;
        }
        if ('computed' in data && data.computed != undefined) {
          this.computed = data.computed;
        }
      }
    }
    get tupleSet() {
      return pb_1.Message.getWrapperField(this, TupleSet, 1) as TupleSet;
    }
    set tupleSet(value: TupleSet) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_tupleSet() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get computed() {
      return pb_1.Message.getWrapperField(
        this,
        ComputedUserSet,
        2,
      ) as ComputedUserSet;
    }
    set computed(value: ComputedUserSet) {
      pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_computed() {
      return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
      tupleSet?: ReturnType<typeof TupleSet.prototype.toObject>;
      computed?: ReturnType<typeof ComputedUserSet.prototype.toObject>;
    }): TupleToUserSet {
      const message = new TupleToUserSet({});
      if (data.tupleSet != null) {
        message.tupleSet = TupleSet.fromObject(data.tupleSet);
      }
      if (data.computed != null) {
        message.computed = ComputedUserSet.fromObject(data.computed);
      }
      return message;
    }
    toObject() {
      const data: {
        tupleSet?: ReturnType<typeof TupleSet.prototype.toObject>;
        computed?: ReturnType<typeof ComputedUserSet.prototype.toObject>;
      } = {};
      if (this.tupleSet != null) {
        data.tupleSet = this.tupleSet.toObject();
      }
      if (this.computed != null) {
        data.computed = this.computed.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_tupleSet)
        writer.writeMessage(1, this.tupleSet, () =>
          this.tupleSet.serialize(writer),
        );
      if (this.has_computed)
        writer.writeMessage(2, this.computed, () =>
          this.computed.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TupleToUserSet {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new TupleToUserSet();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.tupleSet,
              () => (message.tupleSet = TupleSet.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.computed,
              () => (message.computed = ComputedUserSet.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TupleToUserSet {
      return TupleToUserSet.deserialize(bytes);
    }
  }
  export class TupleSet extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { relation?: string }): TupleSet {
      const message = new TupleSet({});
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        relation?: string;
      } = {};
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.relation.length) writer.writeString(1, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TupleSet {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new TupleSet();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TupleSet {
      return TupleSet.deserialize(bytes);
    }
  }
  export class Tuple extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity?: Entity;
            relation?: string;
            subject?: Subject;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
        if ('subject' in data && data.subject != undefined) {
          this.subject = data.subject;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(this, Entity, 1) as Entity;
    }
    set entity(value: Entity) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get subject() {
      return pb_1.Message.getWrapperField(this, Subject, 3) as Subject;
    }
    set subject(value: Subject) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_subject() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      entity?: ReturnType<typeof Entity.prototype.toObject>;
      relation?: string;
      subject?: ReturnType<typeof Subject.prototype.toObject>;
    }): Tuple {
      const message = new Tuple({});
      if (data.entity != null) {
        message.entity = Entity.fromObject(data.entity);
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      if (data.subject != null) {
        message.subject = Subject.fromObject(data.subject);
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof Entity.prototype.toObject>;
        relation?: string;
        subject?: ReturnType<typeof Subject.prototype.toObject>;
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      if (this.subject != null) {
        data.subject = this.subject.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.relation.length) writer.writeString(2, this.relation);
      if (this.has_subject)
        writer.writeMessage(3, this.subject, () =>
          this.subject.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tuple {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Tuple();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = Entity.deserialize(reader)),
            );
            break;
          case 2:
            message.relation = reader.readString();
            break;
          case 3:
            reader.readMessage(
              message.subject,
              () => (message.subject = Subject.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tuple {
      return Tuple.deserialize(bytes);
    }
  }
  export class Attribute extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity?: Entity;
            attribute?: string;
            value?: dependency_2.google.protobuf.Any;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('attribute' in data && data.attribute != undefined) {
          this.attribute = data.attribute;
        }
        if ('value' in data && data.value != undefined) {
          this.value = data.value;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(this, Entity, 1) as Entity;
    }
    set entity(value: Entity) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get attribute() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set attribute(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get value() {
      return pb_1.Message.getWrapperField(
        this,
        dependency_2.google.protobuf.Any,
        3,
      ) as dependency_2.google.protobuf.Any;
    }
    set value(value: dependency_2.google.protobuf.Any) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_value() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      entity?: ReturnType<typeof Entity.prototype.toObject>;
      attribute?: string;
      value?: ReturnType<
        typeof dependency_2.google.protobuf.Any.prototype.toObject
      >;
    }): Attribute {
      const message = new Attribute({});
      if (data.entity != null) {
        message.entity = Entity.fromObject(data.entity);
      }
      if (data.attribute != null) {
        message.attribute = data.attribute;
      }
      if (data.value != null) {
        message.value = dependency_2.google.protobuf.Any.fromObject(data.value);
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof Entity.prototype.toObject>;
        attribute?: string;
        value?: ReturnType<
          typeof dependency_2.google.protobuf.Any.prototype.toObject
        >;
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.attribute != null) {
        data.attribute = this.attribute;
      }
      if (this.value != null) {
        data.value = this.value.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.attribute.length) writer.writeString(2, this.attribute);
      if (this.has_value)
        writer.writeMessage(3, this.value, () => this.value.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Attribute {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Attribute();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = Entity.deserialize(reader)),
            );
            break;
          case 2:
            message.attribute = reader.readString();
            break;
          case 3:
            reader.readMessage(
              message.value,
              () =>
                (message.value =
                  dependency_2.google.protobuf.Any.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Attribute {
      return Attribute.deserialize(bytes);
    }
  }
  export class Tuples extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            tuples?: Tuple[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('tuples' in data && data.tuples != undefined) {
          this.tuples = data.tuples;
        }
      }
    }
    get tuples() {
      return pb_1.Message.getRepeatedWrapperField(this, Tuple, 1) as Tuple[];
    }
    set tuples(value: Tuple[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      tuples?: ReturnType<typeof Tuple.prototype.toObject>[];
    }): Tuples {
      const message = new Tuples({});
      if (data.tuples != null) {
        message.tuples = data.tuples.map((item) => Tuple.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        tuples?: ReturnType<typeof Tuple.prototype.toObject>[];
      } = {};
      if (this.tuples != null) {
        data.tuples = this.tuples.map((item: Tuple) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.tuples.length)
        writer.writeRepeatedMessage(1, this.tuples, (item: Tuple) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tuples {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Tuples();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.tuples, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                Tuple.deserialize(reader),
                Tuple,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tuples {
      return Tuples.deserialize(bytes);
    }
  }
  export class Attributes extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            attributes?: Attribute[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('attributes' in data && data.attributes != undefined) {
          this.attributes = data.attributes;
        }
      }
    }
    get attributes() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Attribute,
        1,
      ) as Attribute[];
    }
    set attributes(value: Attribute[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      attributes?: ReturnType<typeof Attribute.prototype.toObject>[];
    }): Attributes {
      const message = new Attributes({});
      if (data.attributes != null) {
        message.attributes = data.attributes.map((item) =>
          Attribute.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        attributes?: ReturnType<typeof Attribute.prototype.toObject>[];
      } = {};
      if (this.attributes != null) {
        data.attributes = this.attributes.map((item: Attribute) =>
          item.toObject(),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.attributes.length)
        writer.writeRepeatedMessage(1, this.attributes, (item: Attribute) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Attributes {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Attributes();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.attributes, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                Attribute.deserialize(reader),
                Attribute,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Attributes {
      return Attributes.deserialize(bytes);
    }
  }
  export class Entity extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            type?: string;
            id?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
        if ('id' in data && data.id != undefined) {
          this.id = data.id;
        }
      }
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set type(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get id() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set id(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: { type?: string; id?: string }): Entity {
      const message = new Entity({});
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.id != null) {
        message.id = data.id;
      }
      return message;
    }
    toObject() {
      const data: {
        type?: string;
        id?: string;
      } = {};
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.id != null) {
        data.id = this.id;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.type.length) writer.writeString(1, this.type);
      if (this.id.length) writer.writeString(2, this.id);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Entity {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Entity();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.type = reader.readString();
            break;
          case 2:
            message.id = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Entity {
      return Entity.deserialize(bytes);
    }
  }
  export class EntityAndRelation extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity?: Entity;
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(this, Entity, 1) as Entity;
    }
    set entity(value: Entity) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      entity?: ReturnType<typeof Entity.prototype.toObject>;
      relation?: string;
    }): EntityAndRelation {
      const message = new EntityAndRelation({});
      if (data.entity != null) {
        message.entity = Entity.fromObject(data.entity);
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof Entity.prototype.toObject>;
        relation?: string;
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.relation.length) writer.writeString(2, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): EntityAndRelation {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new EntityAndRelation();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = Entity.deserialize(reader)),
            );
            break;
          case 2:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EntityAndRelation {
      return EntityAndRelation.deserialize(bytes);
    }
  }
  export class Subject extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            type?: string;
            id?: string;
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
        if ('id' in data && data.id != undefined) {
          this.id = data.id;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set type(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get id() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set id(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      type?: string;
      id?: string;
      relation?: string;
    }): Subject {
      const message = new Subject({});
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.id != null) {
        message.id = data.id;
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        type?: string;
        id?: string;
        relation?: string;
      } = {};
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.id != null) {
        data.id = this.id;
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.type.length) writer.writeString(1, this.type);
      if (this.id.length) writer.writeString(2, this.id);
      if (this.relation.length) writer.writeString(3, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Subject {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Subject();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.type = reader.readString();
            break;
          case 2:
            message.id = reader.readString();
            break;
          case 3:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Subject {
      return Subject.deserialize(bytes);
    }
  }
  export class AttributeFilter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity?: EntityFilter;
            attributes?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('attributes' in data && data.attributes != undefined) {
          this.attributes = data.attributes;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(
        this,
        EntityFilter,
        1,
      ) as EntityFilter;
    }
    set entity(value: EntityFilter) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get attributes() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set attributes(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
      entity?: ReturnType<typeof EntityFilter.prototype.toObject>;
      attributes?: string[];
    }): AttributeFilter {
      const message = new AttributeFilter({});
      if (data.entity != null) {
        message.entity = EntityFilter.fromObject(data.entity);
      }
      if (data.attributes != null) {
        message.attributes = data.attributes;
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof EntityFilter.prototype.toObject>;
        attributes?: string[];
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.attributes != null) {
        data.attributes = this.attributes;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.attributes.length)
        writer.writeRepeatedString(2, this.attributes);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AttributeFilter {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new AttributeFilter();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = EntityFilter.deserialize(reader)),
            );
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AttributeFilter {
      return AttributeFilter.deserialize(bytes);
    }
  }
  export class TupleFilter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            entity?: EntityFilter;
            relation?: string;
            subject?: SubjectFilter;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
        if ('subject' in data && data.subject != undefined) {
          this.subject = data.subject;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(
        this,
        EntityFilter,
        1,
      ) as EntityFilter;
    }
    set entity(value: EntityFilter) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get subject() {
      return pb_1.Message.getWrapperField(
        this,
        SubjectFilter,
        3,
      ) as SubjectFilter;
    }
    set subject(value: SubjectFilter) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_subject() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      entity?: ReturnType<typeof EntityFilter.prototype.toObject>;
      relation?: string;
      subject?: ReturnType<typeof SubjectFilter.prototype.toObject>;
    }): TupleFilter {
      const message = new TupleFilter({});
      if (data.entity != null) {
        message.entity = EntityFilter.fromObject(data.entity);
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      if (data.subject != null) {
        message.subject = SubjectFilter.fromObject(data.subject);
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof EntityFilter.prototype.toObject>;
        relation?: string;
        subject?: ReturnType<typeof SubjectFilter.prototype.toObject>;
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      if (this.subject != null) {
        data.subject = this.subject.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.relation.length) writer.writeString(2, this.relation);
      if (this.has_subject)
        writer.writeMessage(3, this.subject, () =>
          this.subject.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TupleFilter {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new TupleFilter();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = EntityFilter.deserialize(reader)),
            );
            break;
          case 2:
            message.relation = reader.readString();
            break;
          case 3:
            reader.readMessage(
              message.subject,
              () => (message.subject = SubjectFilter.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TupleFilter {
      return TupleFilter.deserialize(bytes);
    }
  }
  export class EntityFilter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            type?: string;
            ids?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
        if ('ids' in data && data.ids != undefined) {
          this.ids = data.ids;
        }
      }
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set type(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get ids() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set ids(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: { type?: string; ids?: string[] }): EntityFilter {
      const message = new EntityFilter({});
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.ids != null) {
        message.ids = data.ids;
      }
      return message;
    }
    toObject() {
      const data: {
        type?: string;
        ids?: string[];
      } = {};
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.ids != null) {
        data.ids = this.ids;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.type.length) writer.writeString(1, this.type);
      if (this.ids.length) writer.writeRepeatedString(2, this.ids);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EntityFilter {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new EntityFilter();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.type = reader.readString();
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): EntityFilter {
      return EntityFilter.deserialize(bytes);
    }
  }
  export class SubjectFilter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            type?: string;
            ids?: string[];
            relation?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('type' in data && data.type != undefined) {
          this.type = data.type;
        }
        if ('ids' in data && data.ids != undefined) {
          this.ids = data.ids;
        }
        if ('relation' in data && data.relation != undefined) {
          this.relation = data.relation;
        }
      }
    }
    get type() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set type(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get ids() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set ids(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get relation() {
      return pb_1.Message.getFieldWithDefault(this, 3, '') as string;
    }
    set relation(value: string) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      type?: string;
      ids?: string[];
      relation?: string;
    }): SubjectFilter {
      const message = new SubjectFilter({});
      if (data.type != null) {
        message.type = data.type;
      }
      if (data.ids != null) {
        message.ids = data.ids;
      }
      if (data.relation != null) {
        message.relation = data.relation;
      }
      return message;
    }
    toObject() {
      const data: {
        type?: string;
        ids?: string[];
        relation?: string;
      } = {};
      if (this.type != null) {
        data.type = this.type;
      }
      if (this.ids != null) {
        data.ids = this.ids;
      }
      if (this.relation != null) {
        data.relation = this.relation;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.type.length) writer.writeString(1, this.type);
      if (this.ids.length) writer.writeRepeatedString(2, this.ids);
      if (this.relation.length) writer.writeString(3, this.relation);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SubjectFilter {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new SubjectFilter();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.type = reader.readString();
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          case 3:
            message.relation = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): SubjectFilter {
      return SubjectFilter.deserialize(bytes);
    }
  }
  export class ExpandTreeNode extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            operation?: ExpandTreeNode.Operation;
            children?: Expand[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('operation' in data && data.operation != undefined) {
          this.operation = data.operation;
        }
        if ('children' in data && data.children != undefined) {
          this.children = data.children;
        }
      }
    }
    get operation() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        ExpandTreeNode.Operation.OPERATION_UNSPECIFIED,
      ) as ExpandTreeNode.Operation;
    }
    set operation(value: ExpandTreeNode.Operation) {
      pb_1.Message.setField(this, 1, value);
    }
    get children() {
      return pb_1.Message.getRepeatedWrapperField(this, Expand, 2) as Expand[];
    }
    set children(value: Expand[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      operation?: ExpandTreeNode.Operation;
      children?: ReturnType<typeof Expand.prototype.toObject>[];
    }): ExpandTreeNode {
      const message = new ExpandTreeNode({});
      if (data.operation != null) {
        message.operation = data.operation;
      }
      if (data.children != null) {
        message.children = data.children.map((item) => Expand.fromObject(item));
      }
      return message;
    }
    toObject() {
      const data: {
        operation?: ExpandTreeNode.Operation;
        children?: ReturnType<typeof Expand.prototype.toObject>[];
      } = {};
      if (this.operation != null) {
        data.operation = this.operation;
      }
      if (this.children != null) {
        data.children = this.children.map((item: Expand) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.operation != ExpandTreeNode.Operation.OPERATION_UNSPECIFIED)
        writer.writeEnum(1, this.operation);
      if (this.children.length)
        writer.writeRepeatedMessage(2, this.children, (item: Expand) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExpandTreeNode {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ExpandTreeNode();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.operation = reader.readEnum();
            break;
          case 2:
            reader.readMessage(message.children, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                Expand.deserialize(reader),
                Expand,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ExpandTreeNode {
      return ExpandTreeNode.deserialize(bytes);
    }
  }
  export namespace ExpandTreeNode {
    export enum Operation {
      OPERATION_UNSPECIFIED = 0,
      OPERATION_UNION = 1,
      OPERATION_INTERSECTION = 2,
      OPERATION_EXCLUSION = 3,
    }
  }
  export class Expand extends pb_1.Message {
    #one_of_decls: number[][] = [[4, 5]];
    constructor(
      data?:
        | any[]
        | ({
            entity?: Entity;
            permission?: string;
            arguments?: Argument[];
          } & (
            | {
                expand?: ExpandTreeNode;
                leaf?: never;
              }
            | {
                expand?: never;
                leaf?: ExpandLeaf;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [3],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('entity' in data && data.entity != undefined) {
          this.entity = data.entity;
        }
        if ('permission' in data && data.permission != undefined) {
          this.permission = data.permission;
        }
        if ('arguments' in data && data.arguments != undefined) {
          this.arguments = data.arguments;
        }
        if ('expand' in data && data.expand != undefined) {
          this.expand = data.expand;
        }
        if ('leaf' in data && data.leaf != undefined) {
          this.leaf = data.leaf;
        }
      }
    }
    get entity() {
      return pb_1.Message.getWrapperField(this, Entity, 1) as Entity;
    }
    set entity(value: Entity) {
      pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_entity() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get permission() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set permission(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get arguments() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Argument,
        3,
      ) as Argument[];
    }
    set arguments(value: Argument[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    get expand() {
      return pb_1.Message.getWrapperField(
        this,
        ExpandTreeNode,
        4,
      ) as ExpandTreeNode;
    }
    set expand(value: ExpandTreeNode) {
      pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_expand() {
      return pb_1.Message.getField(this, 4) != null;
    }
    get leaf() {
      return pb_1.Message.getWrapperField(this, ExpandLeaf, 5) as ExpandLeaf;
    }
    set leaf(value: ExpandLeaf) {
      pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_leaf() {
      return pb_1.Message.getField(this, 5) != null;
    }
    get node() {
      const cases: {
        [index: number]: 'none' | 'expand' | 'leaf';
      } = {
        0: 'none',
        4: 'expand',
        5: 'leaf',
      };
      return cases[pb_1.Message.computeOneofCase(this, [4, 5])];
    }
    static fromObject(data: {
      entity?: ReturnType<typeof Entity.prototype.toObject>;
      permission?: string;
      arguments?: ReturnType<typeof Argument.prototype.toObject>[];
      expand?: ReturnType<typeof ExpandTreeNode.prototype.toObject>;
      leaf?: ReturnType<typeof ExpandLeaf.prototype.toObject>;
    }): Expand {
      const message = new Expand({});
      if (data.entity != null) {
        message.entity = Entity.fromObject(data.entity);
      }
      if (data.permission != null) {
        message.permission = data.permission;
      }
      if (data.arguments != null) {
        message.arguments = data.arguments.map((item) =>
          Argument.fromObject(item),
        );
      }
      if (data.expand != null) {
        message.expand = ExpandTreeNode.fromObject(data.expand);
      }
      if (data.leaf != null) {
        message.leaf = ExpandLeaf.fromObject(data.leaf);
      }
      return message;
    }
    toObject() {
      const data: {
        entity?: ReturnType<typeof Entity.prototype.toObject>;
        permission?: string;
        arguments?: ReturnType<typeof Argument.prototype.toObject>[];
        expand?: ReturnType<typeof ExpandTreeNode.prototype.toObject>;
        leaf?: ReturnType<typeof ExpandLeaf.prototype.toObject>;
      } = {};
      if (this.entity != null) {
        data.entity = this.entity.toObject();
      }
      if (this.permission != null) {
        data.permission = this.permission;
      }
      if (this.arguments != null) {
        data.arguments = this.arguments.map((item: Argument) =>
          item.toObject(),
        );
      }
      if (this.expand != null) {
        data.expand = this.expand.toObject();
      }
      if (this.leaf != null) {
        data.leaf = this.leaf.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_entity)
        writer.writeMessage(1, this.entity, () =>
          this.entity.serialize(writer),
        );
      if (this.permission.length) writer.writeString(2, this.permission);
      if (this.arguments.length)
        writer.writeRepeatedMessage(3, this.arguments, (item: Argument) =>
          item.serialize(writer),
        );
      if (this.has_expand)
        writer.writeMessage(4, this.expand, () =>
          this.expand.serialize(writer),
        );
      if (this.has_leaf)
        writer.writeMessage(5, this.leaf, () => this.leaf.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Expand {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Expand();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.entity,
              () => (message.entity = Entity.deserialize(reader)),
            );
            break;
          case 2:
            message.permission = reader.readString();
            break;
          case 3:
            reader.readMessage(message.arguments, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                3,
                Argument.deserialize(reader),
                Argument,
              ),
            );
            break;
          case 4:
            reader.readMessage(
              message.expand,
              () => (message.expand = ExpandTreeNode.deserialize(reader)),
            );
            break;
          case 5:
            reader.readMessage(
              message.leaf,
              () => (message.leaf = ExpandLeaf.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Expand {
      return Expand.deserialize(bytes);
    }
  }
  export class ExpandLeaf extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2, 3]];
    constructor(
      data?:
        | any[]
        | ({} & (
            | {
                subjects?: Subjects;
                values?: never;
                value?: never;
              }
            | {
                subjects?: never;
                values?: Values;
                value?: never;
              }
            | {
                subjects?: never;
                values?: never;
                value?: dependency_2.google.protobuf.Any;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('subjects' in data && data.subjects != undefined) {
          this.subjects = data.subjects;
        }
        if ('values' in data && data.values != undefined) {
          this.values = data.values;
        }
        if ('value' in data && data.value != undefined) {
          this.value = data.value;
        }
      }
    }
    get subjects() {
      return pb_1.Message.getWrapperField(this, Subjects, 1) as Subjects;
    }
    set subjects(value: Subjects) {
      pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_subjects() {
      return pb_1.Message.getField(this, 1) != null;
    }
    get values() {
      return pb_1.Message.getWrapperField(this, Values, 2) as Values;
    }
    set values(value: Values) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_values() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get value() {
      return pb_1.Message.getWrapperField(
        this,
        dependency_2.google.protobuf.Any,
        3,
      ) as dependency_2.google.protobuf.Any;
    }
    set value(value: dependency_2.google.protobuf.Any) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_value() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get type() {
      const cases: {
        [index: number]: 'none' | 'subjects' | 'values' | 'value';
      } = {
        0: 'none',
        1: 'subjects',
        2: 'values',
        3: 'value',
      };
      return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
    }
    static fromObject(data: {
      subjects?: ReturnType<typeof Subjects.prototype.toObject>;
      values?: ReturnType<typeof Values.prototype.toObject>;
      value?: ReturnType<
        typeof dependency_2.google.protobuf.Any.prototype.toObject
      >;
    }): ExpandLeaf {
      const message = new ExpandLeaf({});
      if (data.subjects != null) {
        message.subjects = Subjects.fromObject(data.subjects);
      }
      if (data.values != null) {
        message.values = Values.fromObject(data.values);
      }
      if (data.value != null) {
        message.value = dependency_2.google.protobuf.Any.fromObject(data.value);
      }
      return message;
    }
    toObject() {
      const data: {
        subjects?: ReturnType<typeof Subjects.prototype.toObject>;
        values?: ReturnType<typeof Values.prototype.toObject>;
        value?: ReturnType<
          typeof dependency_2.google.protobuf.Any.prototype.toObject
        >;
      } = {};
      if (this.subjects != null) {
        data.subjects = this.subjects.toObject();
      }
      if (this.values != null) {
        data.values = this.values.toObject();
      }
      if (this.value != null) {
        data.value = this.value.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.has_subjects)
        writer.writeMessage(1, this.subjects, () =>
          this.subjects.serialize(writer),
        );
      if (this.has_values)
        writer.writeMessage(2, this.values, () =>
          this.values.serialize(writer),
        );
      if (this.has_value)
        writer.writeMessage(3, this.value, () => this.value.serialize(writer));
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ExpandLeaf {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new ExpandLeaf();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(
              message.subjects,
              () => (message.subjects = Subjects.deserialize(reader)),
            );
            break;
          case 2:
            reader.readMessage(
              message.values,
              () => (message.values = Values.deserialize(reader)),
            );
            break;
          case 3:
            reader.readMessage(
              message.value,
              () =>
                (message.value =
                  dependency_2.google.protobuf.Any.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ExpandLeaf {
      return ExpandLeaf.deserialize(bytes);
    }
  }
  export class Values extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            values?: Map<string, dependency_2.google.protobuf.Any>;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('values' in data && data.values != undefined) {
          this.values = data.values;
        }
      }
      if (!this.values) this.values = new Map();
    }
    get values() {
      return pb_1.Message.getField(this, 1) as any as Map<
        string,
        dependency_2.google.protobuf.Any
      >;
    }
    set values(value: Map<string, dependency_2.google.protobuf.Any>) {
      pb_1.Message.setField(this, 1, value as any);
    }
    static fromObject(data: {
      values?: {
        [key: string]: ReturnType<
          typeof dependency_2.google.protobuf.Any.prototype.toObject
        >;
      };
    }): Values {
      const message = new Values({});
      if (typeof data.values == 'object') {
        message.values = new Map(
          Object.entries(data.values).map(([key, value]) => [
            key,
            dependency_2.google.protobuf.Any.fromObject(value),
          ]),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        values?: {
          [key: string]: ReturnType<
            typeof dependency_2.google.protobuf.Any.prototype.toObject
          >;
        };
      } = {};
      if (this.values != null) {
        data.values = Object.fromEntries(
          Array.from(this.values).map(([key, value]) => [
            key,
            value.toObject(),
          ]),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      for (const [key, value] of this.values) {
        writer.writeMessage(1, this.values, () => {
          writer.writeString(1, key);
          writer.writeMessage(2, value, () => value.serialize(writer));
        });
      }
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Values {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Values();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message, () =>
              pb_1.Map.deserializeBinary(
                message.values as any,
                reader,
                reader.readString,
                () => {
                  let value;
                  reader.readMessage(
                    message,
                    () =>
                      (value =
                        dependency_2.google.protobuf.Any.deserialize(reader)),
                  );
                  return value;
                },
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Values {
      return Values.deserialize(bytes);
    }
  }
  export class Subjects extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            subjects?: Subject[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('subjects' in data && data.subjects != undefined) {
          this.subjects = data.subjects;
        }
      }
    }
    get subjects() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Subject,
        1,
      ) as Subject[];
    }
    set subjects(value: Subject[]) {
      pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
      subjects?: ReturnType<typeof Subject.prototype.toObject>[];
    }): Subjects {
      const message = new Subjects({});
      if (data.subjects != null) {
        message.subjects = data.subjects.map((item) =>
          Subject.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        subjects?: ReturnType<typeof Subject.prototype.toObject>[];
      } = {};
      if (this.subjects != null) {
        data.subjects = this.subjects.map((item: Subject) => item.toObject());
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.subjects.length)
        writer.writeRepeatedMessage(1, this.subjects, (item: Subject) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Subjects {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Subjects();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            reader.readMessage(message.subjects, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                1,
                Subject.deserialize(reader),
                Subject,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Subjects {
      return Subjects.deserialize(bytes);
    }
  }
  export class Tenant extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            id?: string;
            name?: string;
            created_at?: dependency_4.google.protobuf.Timestamp;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('id' in data && data.id != undefined) {
          this.id = data.id;
        }
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('created_at' in data && data.created_at != undefined) {
          this.created_at = data.created_at;
        }
      }
    }
    get id() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set id(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 2, value);
    }
    get created_at() {
      return pb_1.Message.getWrapperField(
        this,
        dependency_4.google.protobuf.Timestamp,
        3,
      ) as dependency_4.google.protobuf.Timestamp;
    }
    set created_at(value: dependency_4.google.protobuf.Timestamp) {
      pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_created_at() {
      return pb_1.Message.getField(this, 3) != null;
    }
    static fromObject(data: {
      id?: string;
      name?: string;
      created_at?: ReturnType<
        typeof dependency_4.google.protobuf.Timestamp.prototype.toObject
      >;
    }): Tenant {
      const message = new Tenant({});
      if (data.id != null) {
        message.id = data.id;
      }
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.created_at != null) {
        message.created_at = dependency_4.google.protobuf.Timestamp.fromObject(
          data.created_at,
        );
      }
      return message;
    }
    toObject() {
      const data: {
        id?: string;
        name?: string;
        created_at?: ReturnType<
          typeof dependency_4.google.protobuf.Timestamp.prototype.toObject
        >;
      } = {};
      if (this.id != null) {
        data.id = this.id;
      }
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.created_at != null) {
        data.created_at = this.created_at.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.id.length) writer.writeString(1, this.id);
      if (this.name.length) writer.writeString(2, this.name);
      if (this.has_created_at)
        writer.writeMessage(3, this.created_at, () =>
          this.created_at.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tenant {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Tenant();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.id = reader.readString();
            break;
          case 2:
            message.name = reader.readString();
            break;
          case 3:
            reader.readMessage(
              message.created_at,
              () =>
                (message.created_at =
                  dependency_4.google.protobuf.Timestamp.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Tenant {
      return Tenant.deserialize(bytes);
    }
  }
  export class DataChanges extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            snap_token?: string;
            data_changes?: DataChange[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('snap_token' in data && data.snap_token != undefined) {
          this.snap_token = data.snap_token;
        }
        if ('data_changes' in data && data.data_changes != undefined) {
          this.data_changes = data.data_changes;
        }
      }
    }
    get snap_token() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set snap_token(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get data_changes() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        DataChange,
        2,
      ) as DataChange[];
    }
    set data_changes(value: DataChange[]) {
      pb_1.Message.setRepeatedWrapperField(this, 2, value);
    }
    static fromObject(data: {
      snap_token?: string;
      data_changes?: ReturnType<typeof DataChange.prototype.toObject>[];
    }): DataChanges {
      const message = new DataChanges({});
      if (data.snap_token != null) {
        message.snap_token = data.snap_token;
      }
      if (data.data_changes != null) {
        message.data_changes = data.data_changes.map((item) =>
          DataChange.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        snap_token?: string;
        data_changes?: ReturnType<typeof DataChange.prototype.toObject>[];
      } = {};
      if (this.snap_token != null) {
        data.snap_token = this.snap_token;
      }
      if (this.data_changes != null) {
        data.data_changes = this.data_changes.map((item: DataChange) =>
          item.toObject(),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.snap_token.length) writer.writeString(1, this.snap_token);
      if (this.data_changes.length)
        writer.writeRepeatedMessage(2, this.data_changes, (item: DataChange) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DataChanges {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new DataChanges();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.snap_token = reader.readString();
            break;
          case 2:
            reader.readMessage(message.data_changes, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                2,
                DataChange.deserialize(reader),
                DataChange,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DataChanges {
      return DataChanges.deserialize(bytes);
    }
  }
  export class DataChange extends pb_1.Message {
    #one_of_decls: number[][] = [[2, 3]];
    constructor(
      data?:
        | any[]
        | ({
            operation?: DataChange.Operation;
          } & (
            | {
                tuple?: Tuple;
                attribute?: never;
              }
            | {
                tuple?: never;
                attribute?: Attribute;
              }
          )),
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('operation' in data && data.operation != undefined) {
          this.operation = data.operation;
        }
        if ('tuple' in data && data.tuple != undefined) {
          this.tuple = data.tuple;
        }
        if ('attribute' in data && data.attribute != undefined) {
          this.attribute = data.attribute;
        }
      }
    }
    get operation() {
      return pb_1.Message.getFieldWithDefault(
        this,
        1,
        DataChange.Operation.OPERATION_UNSPECIFIED,
      ) as DataChange.Operation;
    }
    set operation(value: DataChange.Operation) {
      pb_1.Message.setField(this, 1, value);
    }
    get tuple() {
      return pb_1.Message.getWrapperField(this, Tuple, 2) as Tuple;
    }
    set tuple(value: Tuple) {
      pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_tuple() {
      return pb_1.Message.getField(this, 2) != null;
    }
    get attribute() {
      return pb_1.Message.getWrapperField(this, Attribute, 3) as Attribute;
    }
    set attribute(value: Attribute) {
      pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_attribute() {
      return pb_1.Message.getField(this, 3) != null;
    }
    get type() {
      const cases: {
        [index: number]: 'none' | 'tuple' | 'attribute';
      } = {
        0: 'none',
        2: 'tuple',
        3: 'attribute',
      };
      return cases[pb_1.Message.computeOneofCase(this, [2, 3])];
    }
    static fromObject(data: {
      operation?: DataChange.Operation;
      tuple?: ReturnType<typeof Tuple.prototype.toObject>;
      attribute?: ReturnType<typeof Attribute.prototype.toObject>;
    }): DataChange {
      const message = new DataChange({});
      if (data.operation != null) {
        message.operation = data.operation;
      }
      if (data.tuple != null) {
        message.tuple = Tuple.fromObject(data.tuple);
      }
      if (data.attribute != null) {
        message.attribute = Attribute.fromObject(data.attribute);
      }
      return message;
    }
    toObject() {
      const data: {
        operation?: DataChange.Operation;
        tuple?: ReturnType<typeof Tuple.prototype.toObject>;
        attribute?: ReturnType<typeof Attribute.prototype.toObject>;
      } = {};
      if (this.operation != null) {
        data.operation = this.operation;
      }
      if (this.tuple != null) {
        data.tuple = this.tuple.toObject();
      }
      if (this.attribute != null) {
        data.attribute = this.attribute.toObject();
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.operation != DataChange.Operation.OPERATION_UNSPECIFIED)
        writer.writeEnum(1, this.operation);
      if (this.has_tuple)
        writer.writeMessage(2, this.tuple, () => this.tuple.serialize(writer));
      if (this.has_attribute)
        writer.writeMessage(3, this.attribute, () =>
          this.attribute.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DataChange {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new DataChange();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.operation = reader.readEnum();
            break;
          case 2:
            reader.readMessage(
              message.tuple,
              () => (message.tuple = Tuple.deserialize(reader)),
            );
            break;
          case 3:
            reader.readMessage(
              message.attribute,
              () => (message.attribute = Attribute.deserialize(reader)),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DataChange {
      return DataChange.deserialize(bytes);
    }
  }
  export namespace DataChange {
    export enum Operation {
      OPERATION_UNSPECIFIED = 0,
      OPERATION_CREATE = 1,
      OPERATION_DELETE = 2,
    }
  }
  export class StringValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: string;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set data(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: string }): StringValue {
      const message = new StringValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: string;
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writeString(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StringValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StringValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readString();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StringValue {
      return StringValue.deserialize(bytes);
    }
  }
  export class IntegerValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: number;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set data(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: number }): IntegerValue {
      const message = new IntegerValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: number;
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data != 0) writer.writeInt32(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IntegerValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new IntegerValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IntegerValue {
      return IntegerValue.deserialize(bytes);
    }
  }
  export class DoubleValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: number;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set data(value: number) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: number }): DoubleValue {
      const message = new DoubleValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: number;
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data != 0) writer.writeDouble(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DoubleValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new DoubleValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readDouble();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DoubleValue {
      return DoubleValue.deserialize(bytes);
    }
  }
  export class BooleanValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: boolean;
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set data(value: boolean) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: boolean }): BooleanValue {
      const message = new BooleanValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: boolean;
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data != false) writer.writeBool(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BooleanValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new BooleanValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readBool();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BooleanValue {
      return BooleanValue.deserialize(bytes);
    }
  }
  export class StringArrayValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set data(value: string[]) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: string[] }): StringArrayValue {
      const message = new StringArrayValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: string[];
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writeRepeatedString(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): StringArrayValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new StringArrayValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            pb_1.Message.addToRepeatedField(message, 1, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): StringArrayValue {
      return StringArrayValue.deserialize(bytes);
    }
  }
  export class IntegerArrayValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: number[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
    }
    set data(value: number[]) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: number[] }): IntegerArrayValue {
      const message = new IntegerArrayValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: number[];
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writePackedInt32(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): IntegerArrayValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new IntegerArrayValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readPackedInt32();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): IntegerArrayValue {
      return IntegerArrayValue.deserialize(bytes);
    }
  }
  export class DoubleArrayValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: number[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
    }
    set data(value: number[]) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: number[] }): DoubleArrayValue {
      const message = new DoubleArrayValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: number[];
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writePackedDouble(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): DoubleArrayValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new DoubleArrayValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readPackedDouble();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DoubleArrayValue {
      return DoubleArrayValue.deserialize(bytes);
    }
  }
  export class BooleanArrayValue extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            data?: boolean[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('data' in data && data.data != undefined) {
          this.data = data.data;
        }
      }
    }
    get data() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as boolean[];
    }
    set data(value: boolean[]) {
      pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: { data?: boolean[] }): BooleanArrayValue {
      const message = new BooleanArrayValue({});
      if (data.data != null) {
        message.data = data.data;
      }
      return message;
    }
    toObject() {
      const data: {
        data?: boolean[];
      } = {};
      if (this.data != null) {
        data.data = this.data;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.data.length) writer.writePackedBool(1, this.data);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(
      bytes: Uint8Array | pb_1.BinaryReader,
    ): BooleanArrayValue {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new BooleanArrayValue();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.data = reader.readPackedBool();
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): BooleanArrayValue {
      return BooleanArrayValue.deserialize(bytes);
    }
  }
  export class DataBundle extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            name?: string;
            arguments?: string[];
            operations?: Operation[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [2, 3],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('name' in data && data.name != undefined) {
          this.name = data.name;
        }
        if ('arguments' in data && data.arguments != undefined) {
          this.arguments = data.arguments;
        }
        if ('operations' in data && data.operations != undefined) {
          this.operations = data.operations;
        }
      }
    }
    get name() {
      return pb_1.Message.getFieldWithDefault(this, 1, '') as string;
    }
    set name(value: string) {
      pb_1.Message.setField(this, 1, value);
    }
    get arguments() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set arguments(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get operations() {
      return pb_1.Message.getRepeatedWrapperField(
        this,
        Operation,
        3,
      ) as Operation[];
    }
    set operations(value: Operation[]) {
      pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    static fromObject(data: {
      name?: string;
      arguments?: string[];
      operations?: ReturnType<typeof Operation.prototype.toObject>[];
    }): DataBundle {
      const message = new DataBundle({});
      if (data.name != null) {
        message.name = data.name;
      }
      if (data.arguments != null) {
        message.arguments = data.arguments;
      }
      if (data.operations != null) {
        message.operations = data.operations.map((item) =>
          Operation.fromObject(item),
        );
      }
      return message;
    }
    toObject() {
      const data: {
        name?: string;
        arguments?: string[];
        operations?: ReturnType<typeof Operation.prototype.toObject>[];
      } = {};
      if (this.name != null) {
        data.name = this.name;
      }
      if (this.arguments != null) {
        data.arguments = this.arguments;
      }
      if (this.operations != null) {
        data.operations = this.operations.map((item: Operation) =>
          item.toObject(),
        );
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.name.length) writer.writeString(1, this.name);
      if (this.arguments.length) writer.writeRepeatedString(2, this.arguments);
      if (this.operations.length)
        writer.writeRepeatedMessage(3, this.operations, (item: Operation) =>
          item.serialize(writer),
        );
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DataBundle {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new DataBundle();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            message.name = reader.readString();
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          case 3:
            reader.readMessage(message.operations, () =>
              pb_1.Message.addToRepeatedWrapperField(
                message,
                3,
                Operation.deserialize(reader),
                Operation,
              ),
            );
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DataBundle {
      return DataBundle.deserialize(bytes);
    }
  }
  export class Operation extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            relationships_write?: string[];
            relationships_delete?: string[];
            attributes_write?: string[];
            attributes_delete?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1, 2, 3, 4],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if (
          'relationships_write' in data &&
          data.relationships_write != undefined
        ) {
          this.relationships_write = data.relationships_write;
        }
        if (
          'relationships_delete' in data &&
          data.relationships_delete != undefined
        ) {
          this.relationships_delete = data.relationships_delete;
        }
        if ('attributes_write' in data && data.attributes_write != undefined) {
          this.attributes_write = data.attributes_write;
        }
        if (
          'attributes_delete' in data &&
          data.attributes_delete != undefined
        ) {
          this.attributes_delete = data.attributes_delete;
        }
      }
    }
    get relationships_write() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set relationships_write(value: string[]) {
      pb_1.Message.setField(this, 1, value);
    }
    get relationships_delete() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set relationships_delete(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get attributes_write() {
      return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set attributes_write(value: string[]) {
      pb_1.Message.setField(this, 3, value);
    }
    get attributes_delete() {
      return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
    }
    set attributes_delete(value: string[]) {
      pb_1.Message.setField(this, 4, value);
    }
    static fromObject(data: {
      relationships_write?: string[];
      relationships_delete?: string[];
      attributes_write?: string[];
      attributes_delete?: string[];
    }): Operation {
      const message = new Operation({});
      if (data.relationships_write != null) {
        message.relationships_write = data.relationships_write;
      }
      if (data.relationships_delete != null) {
        message.relationships_delete = data.relationships_delete;
      }
      if (data.attributes_write != null) {
        message.attributes_write = data.attributes_write;
      }
      if (data.attributes_delete != null) {
        message.attributes_delete = data.attributes_delete;
      }
      return message;
    }
    toObject() {
      const data: {
        relationships_write?: string[];
        relationships_delete?: string[];
        attributes_write?: string[];
        attributes_delete?: string[];
      } = {};
      if (this.relationships_write != null) {
        data.relationships_write = this.relationships_write;
      }
      if (this.relationships_delete != null) {
        data.relationships_delete = this.relationships_delete;
      }
      if (this.attributes_write != null) {
        data.attributes_write = this.attributes_write;
      }
      if (this.attributes_delete != null) {
        data.attributes_delete = this.attributes_delete;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.relationships_write.length)
        writer.writeRepeatedString(1, this.relationships_write);
      if (this.relationships_delete.length)
        writer.writeRepeatedString(2, this.relationships_delete);
      if (this.attributes_write.length)
        writer.writeRepeatedString(3, this.attributes_write);
      if (this.attributes_delete.length)
        writer.writeRepeatedString(4, this.attributes_delete);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Operation {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Operation();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            pb_1.Message.addToRepeatedField(message, 1, reader.readString());
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          case 3:
            pb_1.Message.addToRepeatedField(message, 3, reader.readString());
            break;
          case 4:
            pb_1.Message.addToRepeatedField(message, 4, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Operation {
      return Operation.deserialize(bytes);
    }
  }
  export class Partials extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(
      data?:
        | any[]
        | {
            write?: string[];
            delete?: string[];
            update?: string[];
          },
    ) {
      super();
      pb_1.Message.initialize(
        this,
        Array.isArray(data) ? data : [],
        0,
        -1,
        [1, 2, 3],
        this.#one_of_decls,
      );
      if (!Array.isArray(data) && typeof data == 'object') {
        if ('write' in data && data.write != undefined) {
          this.write = data.write;
        }
        if ('delete' in data && data.delete != undefined) {
          this.delete = data.delete;
        }
        if ('update' in data && data.update != undefined) {
          this.update = data.update;
        }
      }
    }
    get write() {
      return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set write(value: string[]) {
      pb_1.Message.setField(this, 1, value);
    }
    get delete() {
      return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set delete(value: string[]) {
      pb_1.Message.setField(this, 2, value);
    }
    get update() {
      return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set update(value: string[]) {
      pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
      write?: string[];
      delete?: string[];
      update?: string[];
    }): Partials {
      const message = new Partials({});
      if (data.write != null) {
        message.write = data.write;
      }
      if (data.delete != null) {
        message.delete = data.delete;
      }
      if (data.update != null) {
        message.update = data.update;
      }
      return message;
    }
    toObject() {
      const data: {
        write?: string[];
        delete?: string[];
        update?: string[];
      } = {};
      if (this.write != null) {
        data.write = this.write;
      }
      if (this.delete != null) {
        data.delete = this.delete;
      }
      if (this.update != null) {
        data.update = this.update;
      }
      return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
      const writer = w || new pb_1.BinaryWriter();
      if (this.write.length) writer.writeRepeatedString(1, this.write);
      if (this.delete.length) writer.writeRepeatedString(2, this.delete);
      if (this.update.length) writer.writeRepeatedString(3, this.update);
      if (!w) return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Partials {
      const reader =
          bytes instanceof pb_1.BinaryReader
            ? bytes
            : new pb_1.BinaryReader(bytes),
        message = new Partials();
      while (reader.nextField()) {
        if (reader.isEndGroup()) break;
        switch (reader.getFieldNumber()) {
          case 1:
            pb_1.Message.addToRepeatedField(message, 1, reader.readString());
            break;
          case 2:
            pb_1.Message.addToRepeatedField(message, 2, reader.readString());
            break;
          case 3:
            pb_1.Message.addToRepeatedField(message, 3, reader.readString());
            break;
          default:
            reader.skipField();
        }
      }
      return message;
    }
    serializeBinary(): Uint8Array {
      return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Partials {
      return Partials.deserialize(bytes);
    }
  }
}
